
// NASA API configuration
const NASA_API_KEY = 'VQrZFnlmpMhTIyAutXD4LfXNBIKkR6SO0cw49JFq';
const NASA_API_BASE_URL = 'https://api.nasa.gov/planetary/earth';
const GISS_API_URL = 'https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv';
const OCO2_API_URL = 'https://ocov2.jpl.nasa.gov/ocov2/api/data';
const NSIDC_API_URL = 'https://nsidc.org/api/data';

// World map variables
let worldMap;
let selectedLocationMarker;

// Generate stars
function generateStars() {
    const starsContainer = document.getElementById('stars');
    const starCount = 200;
    
    for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        star.classList.add('star');
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        star.style.animationDelay = `${Math.random() * 4}s`;
        starsContainer.appendChild(star);
    }
}

// Initialize stars on page load
generateStars();

// Hide loading overlay after page loads
window.addEventListener('load', () => {
    setTimeout(() => {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }, 1000);
});

// Initialize world map
function initWorldMap() {
    // Create map
    worldMap = L.map('worldMap').setView([20, 0], 2);
    
    // Add tile layer with dark theme
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    }).addTo(worldMap);
    
    // Add sample data points to show coverage
    const sampleDataPoints = [
        {lat: 40.7128, lng: -74.0060, name: "New York", value: 0.75},
        {lat: 51.5074, lng: -0.1278, name: "London", value: 0.82},
        {lat: 35.6762, lng: 139.6503, name: "Tokyo", value: 0.68},
        {lat: -33.8688, lng: 151.2093, name: "Sydney", value: 0.91},
        {lat: 48.8566, lng: 2.3522, name: "Paris", value: 0.73},
        {lat: 55.7558, lng: 37.6173, name: "Moscow", value: 0.65},
        {lat: -23.5505, lng: -46.6333, name: "São Paulo", value: 0.88},
        {lat: 19.4326, lng: -99.1332, name: "Mexico City", value: 0.79},
        {lat: 28.6139, lng: 77.2090, name: "New Delhi", value: 0.71},
        {lat: 39.9042, lng: 116.4074, name: "Beijing", value: 0.67},
        {lat: -1.2921, lng: 36.8219, name: "Nairobi", value: 0.85},
        {lat: -26.2041, lng: 28.0473, name: "Johannesburg", value: 0.77},
        {lat: 31.2304, lng: 121.4737, name: "Shanghai", value: 0.64},
        {lat: 25.2048, lng: 55.2708, name: "Dubai", value: 0.92},
        {lat: 37.5665, lng: 126.9780, name: "Seoul", value: 0.70}
    ];
    
    // Add markers for sample data points
    sampleDataPoints.forEach(point => {
        const colorIntensity = Math.floor(point.value * 255);
        const color = `rgb(${255 - colorIntensity}, ${colorIntensity}, 100)`;
        
        L.circleMarker([point.lat, point.lng], {
            radius: 8,
            fillColor: color,
            color: '#fff',
            weight: 1,
            opacity: 0.8,
            fillOpacity: 0.7
        }).addTo(worldMap).bindPopup(`<b>${point.name}</b><br>Data Value: ${point.value}`);
    });
    
    // Add click event to map
    worldMap.on('click', function(e) {
        const lat = e.latlng.lat.toFixed(4);
        const lng = e.latlng.lng.toFixed(4);
        
        // Update form fields with clicked coordinates
        document.getElementById('latitude').value = lat;
        document.getElementById('longitude').value = lng;
        
        // Update or create marker
        if (selectedLocationMarker) {
            selectedLocationMarker.setLatLng(e.latlng);
        } else {
            selectedLocationMarker = L.marker(e.latlng, {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(worldMap);
        }
        
        // Try to get location name using reverse geocoding
        fetchLocationName(lat, lng);
    });
}

// Fetch location name using Nominatim API
async function fetchLocationName(lat, lng) {
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`);
        const data = await response.json();
        
        if (data && data.display_name) {
            // Use the city or town name if available, otherwise use the full display name
            const locationName = data.address.city || data.address.town || data.address.county || data.display_name.split(',')[0];
            document.getElementById('location').value = locationName;
        }
    } catch (error) {
        console.error('Error fetching location name:', error);
    }
}

// Smooth scrolling
function scrollToSection(sectionId) {
    const section = document.getElementById(sectionId);
    const stickyInstruments = document.getElementById('stickyInstruments');
    const offset = stickyInstruments.classList.contains('visible') ? 100 : 80;
    
    window.scrollTo({
        top: section.offsetTop - offset,
        behavior: 'smooth'
    });
}

// Navigation active state
document.querySelectorAll('nav a').forEach(link => {
    link.addEventListener('click', function(e) {
        e.preventDefault();
        document.querySelectorAll('nav a').forEach(a => a.classList.remove('active'));
        this.classList.add('active');
        const targetId = this.getAttribute('href').substring(1);
        scrollToSection(targetId);
    });
});

// Sticky instrument selection
function selectStickyInstrument(instrument) {
    updateStickyInstrumentSelection(instrument);
    
    // In a real application, this would load data specific to the selected instrument
    console.log(`Selected instrument: ${instrument}`);
}

// Update sticky instrument selection
function updateStickyInstrumentSelection(instrument) {
    document.querySelectorAll('.sticky-instrument-card').forEach(card => {
        card.classList.remove('active');
    });
    
    // Find and activate the corresponding sticky card
    const stickyCards = document.querySelectorAll('.sticky-instrument-card');
    const instrumentMap = ['aster', 'ceres', 'misr', 'modis', 'mopitt'];
    const index = instrumentMap.indexOf(instrument);
    if (index !== -1 && stickyCards[index]) {
        stickyCards[index].classList.add('active');
    }
}

// Visualization switching
function showViz(vizType) {
    document.querySelectorAll('.viz-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.currentTarget.classList.add('active');
    
    document.querySelectorAll('.viz-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById(`${vizType}-viz`).classList.add('active');
    
    // Update chart based on selection
    updateChart(vizType);
}

// Chart initialization
let tempChart, co2Chart, iceChart, vegChart;

// Fetch data from NASA API
async function fetchNASAData(dataset, startDate, endDate) {
    try {
        let data;
        
        switch(dataset) {
            case 'temperature':
                // Fetch GISTEMP temperature data
                data = await fetchGISTEMPTemperatureData();
                break;
            case 'co2':
                // Fetch CO2 data from OCO-2 satellite
                data = await fetchCO2Data();
                break;
            case 'ice':
                // Fetch sea ice data from NSIDC
                data = await fetchSeaIceData();
                break;
            case 'vegetation':
                // Fetch NDVI data from MODIS
                data = await fetchNDVIData();
                break;
            default:
                // Return mock data if dataset is not recognized
                return getMockData(dataset);
        }
        
        return data;
    } catch (error) {
        console.error('Error fetching NASA data:', error);
        // Return mock data if API fails
        return getMockData(dataset);
    }
}

// Fetch GISTEMP temperature data
async function fetchGISTEMPTemperatureData() {
    try {
        const response = await fetch(GISS_API_URL);
        
        if (!response.ok) {
            throw new Error(`GISS API request failed: ${response.status}`);
        }
        
        const csvData = await response.text();
        return parseGISTEMPCSV(csvData);
    } catch (error) {
        console.error('Error fetching GISTEMP data:', error);
        throw error;
    }
}

// Parse GISTEMP CSV data
function parseGISTEMPCSV(csvData) {
    const lines = csvData.split('\n');
    const labels = [];
    const data = [];
    
    // Skip header lines and parse data
    for (let i = 7; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const parts = line.split(',');
        if (parts.length < 13) continue;
        
        const year = parts[0];
        if (year < '1999' || year > '2023') continue;
        
        // Get annual mean (column 13)
        const value = parseFloat(parts[12]);
        if (isNaN(value)) continue;
        
        labels.push(year);
        data.push(value);
    }
    
    return { labels, data };
}

// Fetch CO2 data
async function fetchCO2Data() {
    try {
        // Using NOAA's CO2 data as an alternative to OCO-2 API
        const response = await fetch('https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_annmean_mlo.csv');
        
        if (!response.ok) {
            throw new Error(`NOAA CO2 API request failed: ${response.status}`);
        }
        
        const csvData = await response.text();
        return parseCO2CSV(csvData);
    } catch (error) {
        console.error('Error fetching CO2 data:', error);
        throw error;
    }
}

// Parse CO2 CSV data
function parseCO2CSV(csvData) {
    const lines = csvData.split('\n');
    const labels = [];
    const data = [];
    
    // Skip header line and parse data
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const parts = line.split(',');
        if (parts.length < 2) continue;
        
        const year = parts[0];
        if (year < '1999' || year > '2023') continue;
        
        const value = parseFloat(parts[1]);
        if (isNaN(value)) continue;
        
        labels.push(year);
        data.push(value);
    }
    
    return { labels, data };
}

// Fetch sea ice data
async function fetchSeaIceData() {
    try {
        // Using NSIDC sea ice data
        const response = await fetch('https://nsidc.org/data/seaice_index/archives/Sea_Ice_Index_Monthly_Data_by_Year_G02135_v3.0.xlsx');
        
        if (!response.ok) {
            throw new Error(`NSIDC API request failed: ${response.status}`);
        }
        
        // Since we can't directly parse Excel in the browser, we'll use a CSV alternative
        const csvResponse = await fetch('https://raw.githubusercontent.com/datasets/sea-ice-index/master/data/annual-extent.csv');
        const csvData = await csvResponse.text();
        
        return parseSeaIceCSV(csvData);
    } catch (error) {
        console.error('Error fetching sea ice data:', error);
        throw error;
    }
}

// Parse sea ice CSV data
function parseSeaIceCSV(csvData) {
    const lines = csvData.split('\n');
    const labels = [];
    const data = [];
    
    // Skip header line and parse data
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const parts = line.split(',');
        if (parts.length < 3) continue;
        
        const year = parts[0];
        if (year < '1999' || year > '2023') continue;
        
        // Get Arctic September extent (column 3)
        const value = parseFloat(parts[2]);
        if (isNaN(value)) continue;
        
        labels.push(year);
        data.push(value);
    }
    
    return { labels, data };
}

// Fetch NDVI data
async function fetchNDVIData() {
    try {
        // Using MODIS NDVI data from NASA Earthdata
        // Since direct API access requires authentication, we'll use a public dataset
        const response = await fetch('https://raw.githubusercontent.com/earthlab/modis-ndvi-time-series/master/data/ndvi_timeseries.csv');
        
        if (!response.ok) {
            throw new Error(`NDVI API request failed: ${response.status}`);
        }
        
        const csvData = await response.text();
        return parseNDVICSV(csvData);
    } catch (error) {
        console.error('Error fetching NDVI data:', error);
        throw error;
    }
}

// Parse NDVI CSV data
function parseNDVICSV(csvData) {
    const lines = csvData.split('\n');
    const labels = [];
    const data = [];
    
    // Skip header line and parse data
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const parts = line.split(',');
        if (parts.length < 2) continue;
        
        const year = parts[0];
        if (year < '1999' || year > '2023') continue;
        
        const value = parseFloat(parts[1]);
        if (isNaN(value)) continue;
        
        labels.push(year);
        data.push(value);
    }
    
    return { labels, data };
}

// Get mock data for demonstration
function getMockData(dataset) {
    const years = ['1999', '2001', '2003', '2005', '2007', '2009', '2011', '2013', '2015', '2017', '2019', '2021', '2023'];
    
    switch(dataset) {
        case 'temperature':
            return {
                labels: years,
                data: [0.42, 0.54, 0.62, 0.68, 0.66, 0.65, 0.59, 0.67, 0.87, 0.92, 0.98, 0.85, 1.17]
            };
        case 'co2':
            return {
                labels: years,
                data: [368, 371, 376, 380, 384, 387, 391, 397, 401, 406, 411, 416, 421]
            };
        case 'ice':
            return {
                labels: years,
                data: [7.0, 6.9, 6.7, 6.5, 6.3, 5.9, 5.7, 5.4, 5.2, 4.9, 4.7, 4.5, 4.3]
            };
        case 'vegetation':
            return {
                labels: years,
                data: [0.46, 0.462, 0.464, 0.465, 0.466, 0.467, 0.468, 0.469, 0.47, 0.471, 0.472, 0.473, 0.474]
            };
        default:
            return { labels: years, data: [] };
    }
}

// Initialize charts with data
async function initCharts() {
    // Temperature Chart
    const tempCtx = document.getElementById('tempChart').getContext('2d');
    const tempLoading = document.getElementById('temp-loading');
    
    // Show loading indicator
    tempLoading.style.display = 'flex';
    
    // Fetch temperature data
    const tempData = await fetchNASAData('temperature', '1999-01-01', '2023-12-31');
    
    tempChart = new Chart(tempCtx, {
        type: 'line',
        data: {
            labels: tempData.labels,
            datasets: [{
                label: 'Global Temperature Anomaly (°C)',
                data: tempData.data,
                borderColor: '#ff5722',
                backgroundColor: 'rgba(255, 87, 34, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: '#b3e5fc'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.raw}°C`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    ticks: {
                        color: '#b3e5fc',
                        callback: function(value) {
                            return value + '°C';
                        }
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                },
                x: {
                    ticks: {
                        color: '#b3e5fc'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            }
        }
    });
    
    // Hide loading indicator
    tempLoading.style.display = 'none';
    
    // CO2 Chart
    const co2Ctx = document.getElementById('co2Chart').getContext('2d');
    const co2Loading = document.getElementById('co2-loading');
    
    // Show loading indicator
    co2Loading.style.display = 'flex';
    
    // Fetch CO2 data
    const co2Data = await fetchNASAData('co2', '1999-01-01', '2023-12-31');
    
    co2Chart = new Chart(co2Ctx, {
        type: 'line',
        data: {
            labels: co2Data.labels,
            datasets: [{
                label: 'Atmospheric CO2 (ppm)',
                data: co2Data.data,
                borderColor: '#4caf50',
                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: '#b3e5fc'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.raw} ppm`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    ticks: {
                        color: '#b3e5fc',
                        callback: function(value) {
                            return value + ' ppm';
                        }
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                },
                x: {
                    ticks: {
                        color: '#b3e5fc'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            }
        }
    });
    
    // Hide loading indicator
    co2Loading.style.display = 'none';
    
    // Ice Chart
    const iceCtx = document.getElementById('iceChart').getContext('2d');
    const iceLoading = document.getElementById('ice-loading');
    
    // Show loading indicator
    iceLoading.style.display = 'flex';
    
    // Fetch ice data
    const iceData = await fetchNASAData('ice', '1999-01-01', '2023-12-31');
    
    iceChart = new Chart(iceCtx, {
        type: 'line',
        data: {
            labels: iceData.labels,
            datasets: [{
                label: 'Arctic Sea Ice Extent (million sq km)',
                data: iceData.data,
                borderColor: '#03a9f4',
                backgroundColor: 'rgba(3, 169, 244, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: '#b3e5fc'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.raw} million sq km`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    ticks: {
                        color: '#b3e5fc',
                        callback: function(value) {
                            return value + ' M km²';
                        }
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                },
                x: {
                    ticks: {
                        color: '#b3e5fc'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            }
        }
    });
    
    // Hide loading indicator
    iceLoading.style.display = 'none';
    
    // Vegetation Chart
    const vegCtx = document.getElementById('vegChart').getContext('2d');
    const vegLoading = document.getElementById('veg-loading');
    
    // Show loading indicator
    vegLoading.style.display = 'flex';
    
    // Fetch vegetation data
    const vegData = await fetchNASAData('vegetation', '1999-01-01', '2023-12-31');
    
    vegChart = new Chart(vegCtx, {
        type: 'line',
        data: {
            labels: vegData.labels,
            datasets: [{
                label: 'Global Vegetation Index (NDVI)',
                data: vegData.data,
                borderColor: '#8bc34a',
                backgroundColor: 'rgba(139, 195, 74, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    labels: {
                        color: '#b3e5fc'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.raw}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    ticks: {
                        color: '#b3e5fc'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                },
                x: {
                    ticks: {
                        color: '#b3e5fc'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            }
        }
    });
    
    // Hide loading indicator
    vegLoading.style.display = 'none';
}

// Update chart with animation
function updateChart(chartType) {
    // In a real application, this would update the chart with new data
    // For this demo, we'll just trigger a resize to ensure the chart displays properly
    switch(chartType) {
        case 'temperature':
            tempChart.resize();
            break;
        case 'co2':
            co2Chart.resize();
            break;
        case 'ice':
            iceChart.resize();
            break;
        case 'vegetation':
            vegChart.resize();
            break;
    }
}

// Initialize charts and map when the page loads
window.addEventListener('load', () => {
    initCharts();
    initWorldMap();
});

// Add parallax effect to hero section
window.addEventListener('scroll', () => {
    const scrolled = window.pageYOffset;
    const parallax = document.querySelector('.hero');
    parallax.style.transform = `translateY(${scrolled * 0.5}px)`;
    
    // Show/hide sticky instruments based on scroll position
    const stickyInstruments = document.getElementById('stickyInstruments');
    const scrollPosition = window.scrollY;
    
    // Show sticky navigation after scrolling past the hero section
    if (scrollPosition > 200) {
        stickyInstruments.classList.add('visible');
    } else {
        stickyInstruments.classList.remove('visible');
    }
});

// 3D Earth initialization
let scene, camera, renderer, earth, earthGroup, atmosphere, clouds;
let mouseX = 0, mouseY = 0;
let targetRotationX = 0, targetRotationY = 0;
let isMouseDown = false;
let previousMousePosition = { x: 0, y: 0 };

function init3DEarth() {
    const container = document.getElementById('globe-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    // Create scene
    scene = new THREE.Scene();
    
    // Create camera
    camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.z = 2.5;
    
    // Create renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);
    
    // Create Earth group
    earthGroup = new THREE.Group();
    scene.add(earthGroup);
    
    // Create Earth
    const geometry = new THREE.SphereGeometry(1, 64, 64);
    
    // Load Earth texture
    const textureLoader = new THREE.TextureLoader();
    
    // Use a proper Earth texture URL
    const earthTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthSpecularMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg');
    const earthNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg');
    
    const material = new THREE.MeshPhongMaterial({
        map: earthTexture,
        specularMap: earthSpecularMap,
        normalMap: earthNormalMap,
        bumpScale: 0.05,
        specular: new THREE.Color('grey'),
        shininess: 10
    });
    
    earth = new THREE.Mesh(geometry, material);
    earthGroup.add(earth);
    
    // Add clouds
    const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
    const cloudTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');
    
    const cloudMaterial = new THREE.MeshPhongMaterial({
        map: cloudTexture,
        opacity: 0.4,
        transparent: true,
        depthWrite: false
    });
    
    clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
    earthGroup.add(clouds);
    
    // Add atmosphere glow
    const atmosphereGeometry = new THREE.SphereGeometry(1.1, 64, 64);
    const atmosphereMaterial = new THREE.ShaderMaterial({
        vertexShader: `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vNormal;
            void main() {
                float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true
    });
    
    atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    earthGroup.add(atmosphere);
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 3, 5);
    scene.add(directionalLight);
    
    // Add a second light for better contrast
    const directionalLight2 = new THREE.DirectionalLight(0x7c7cff, 0.3);
    directionalLight2.position.set(-5, -3, -5);
    scene.add(directionalLight2);
    
    // Add mouse controls
    container.addEventListener('mousedown', onMouseDown);
    container.addEventListener('mousemove', onMouseMove);
    container.addEventListener('mouseup', onMouseUp);
    container.addEventListener('mouseleave', onMouseUp);
    
    // Add touch controls for mobile
    container.addEventListener('touchstart', onTouchStart);
    container.addEventListener('touchmove', onTouchMove);
    container.addEventListener('touchend', onTouchEnd);
    
    // Add scroll zoom
    container.addEventListener('wheel', onMouseWheel);
    
    // Start animation
    animate3DEarth();
}

function onMouseDown(event) {
    isMouseDown = true;
    previousMousePosition = {
        x: event.clientX,
        y: event.clientY
    };
}

function onMouseMove(event) {
    if (isMouseDown) {
        const deltaMove = {
            x: event.clientX - previousMousePosition.x,
            y: event.clientY - previousMousePosition.y
        };
        
        targetRotationY += deltaMove.x * 0.01;
        targetRotationX += deltaMove.y * 0.01;
        
        previousMousePosition = {
            x: event.clientX,
            y: event.clientY
        };
    }
}

function onMouseUp() {
    isMouseDown = false;
}

function onTouchStart(event) {
    if (event.touches.length === 1) {
        isMouseDown = true;
        previousMousePosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
    }
}

function onTouchMove(event) {
    if (event.touches.length === 1 && isMouseDown) {
        event.preventDefault();
        const deltaMove = {
            x: event.touches[0].clientX - previousMousePosition.x,
            y: event.touches[0].clientY - previousMousePosition.y
        };
        
        targetRotationY += deltaMove.x * 0.01;
        targetRotationX += deltaMove.y * 0.01;
        
        previousMousePosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
    }
}

function onTouchEnd() {
    isMouseDown = false;
}

function onMouseWheel(event) {
    event.preventDefault();
    const delta = event.deltaY * 0.001;
    camera.position.z = Math.max(1.5, Math.min(4, camera.position.z + delta));
}

function animate3DEarth() {
    requestAnimationFrame(animate3DEarth);
    
    // Auto-rotate when not interacting
    if (!isMouseDown) {
        targetRotationY += 0.002;
    }
    
    // Smooth rotation
    earthGroup.rotation.x += (targetRotationX - earthGroup.rotation.x) * 0.05;
    earthGroup.rotation.y += (targetRotationY - earthGroup.rotation.y) * 0.05;
    
    // Limit vertical rotation
    earthGroup.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, earthGroup.rotation.x));
    
    // Rotate clouds slightly faster than Earth
    if (clouds) {
        clouds.rotation.y += 0.0005;
    }
    
    renderer.render(scene, camera);
}

// Initialize 3D Earth when page loads
window.addEventListener('load', init3DEarth);

// Handle window resize
window.addEventListener('resize', () => {
    const container = document.getElementById('globe-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    if (camera && renderer) {
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    }
    
    // Also resize the world map
    if (worldMap) {
        worldMap.invalidateSize();
    }
});

// Data Globe 3D Earth initialization
let dataScene, dataCamera, dataRenderer, dataEarth, dataEarthGroup, dataAtmosphere, dataClouds;
let dataLayers = {
    temperature: null,
    vegetation: null,
    waterVapor: null,
    aerosols: null,
    clouds: null
};
let dataMouseX = 0, dataMouseY = 0;
let dataTargetRotationX = 0, dataTargetRotationY = 0;
let dataIsMouseDown = false;
let dataPreviousMousePosition = { x: 0, y: 0 };
let activeDataset = null;

function initDataGlobe() {
    const container = document.getElementById('data-globe-container');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    // Create scene
    dataScene = new THREE.Scene();
    
    // Create camera
    dataCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    dataCamera.position.z = 2.5;
    
    // Create renderer
    dataRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    dataRenderer.setSize(width, height);
    dataRenderer.setClearColor(0x000000, 0);
    container.appendChild(dataRenderer.domElement);
    
    // Create Earth group
    dataEarthGroup = new THREE.Group();
    dataScene.add(dataEarthGroup);
    
    // Create Earth
    const geometry = new THREE.SphereGeometry(1, 64, 64);
    
    // Load Earth texture
    const textureLoader = new THREE.TextureLoader();
    
    // Use a proper Earth texture URL
    const earthTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg');
    const earthSpecularMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg');
    const earthNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg');
    
    const material = new THREE.MeshPhongMaterial({
        map: earthTexture,
        specularMap: earthSpecularMap,
        normalMap: earthNormalMap,
        bumpScale: 0.05,
        specular: new THREE.Color('grey'),
        shininess: 10
    });
    
    dataEarth = new THREE.Mesh(geometry, material);
    dataEarthGroup.add(dataEarth);
    
    // Add clouds
    const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
    const cloudTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png');
    
    const cloudMaterial = new THREE.MeshPhongMaterial({
        map: cloudTexture,
        opacity: 0.4,
        transparent: true,
        depthWrite: false
    });
    
    dataClouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
    dataEarthGroup.add(dataClouds);
    
    // Add atmosphere glow
    const atmosphereGeometry = new THREE.SphereGeometry(1.1, 64, 64);
    const atmosphereMaterial = new THREE.ShaderMaterial({
        vertexShader: `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vNormal;
            void main() {
                float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true
    });
    
    dataAtmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    dataEarthGroup.add(dataAtmosphere);
    
    // Create data layers
    createDataLayers();
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0x333333);
    dataScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 3, 5);
    dataScene.add(directionalLight);
    
    // Add a second light for better contrast
    const directionalLight2 = new THREE.DirectionalLight(0x7c7cff, 0.3);
    directionalLight2.position.set(-5, -3, -5);
    dataScene.add(directionalLight2);
    
    // Add mouse controls
    container.addEventListener('mousedown', onDataMouseDown);
    container.addEventListener('mousemove', onDataMouseMove);
    container.addEventListener('mouseup', onDataMouseUp);
    container.addEventListener('mouseleave', onDataMouseUp);
    
    // Add touch controls for mobile
    container.addEventListener('touchstart', onDataTouchStart);
    container.addEventListener('touchmove', onDataTouchMove);
    container.addEventListener('touchend', onDataTouchEnd);
    
    // Add scroll zoom
    container.addEventListener('wheel', onDataMouseWheel);
    
    // Start animation
    animateDataGlobe();
}

function createDataLayers() {
    const textureLoader = new THREE.TextureLoader();
    
    // Temperature layer (red/orange)
    const tempGeometry = new THREE.SphereGeometry(1.02, 64, 64);
    const tempMaterial = new THREE.MeshBasicMaterial({
        color: 0xff5722,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });
    dataLayers.temperature = new THREE.Mesh(tempGeometry, tempMaterial);
    dataEarthGroup.add(dataLayers.temperature);
    
    // Vegetation layer (green)
    const vegGeometry = new THREE.SphereGeometry(1.03, 64, 64);
    const vegMaterial = new THREE.MeshBasicMaterial({
        color: 0x8bc34a,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });
    dataLayers.vegetation = new THREE.Mesh(vegGeometry, vegMaterial);
    dataEarthGroup.add(dataLayers.vegetation);
    
    // Water vapor layer (blue)
    const waterGeometry = new THREE.SphereGeometry(1.04, 64, 64);
    const waterMaterial = new THREE.MeshBasicMaterial({
        color: 0x03a9f4,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });
    dataLayers.waterVapor = new THREE.Mesh(waterGeometry, waterMaterial);
    dataEarthGroup.add(dataLayers.waterVapor);
    
    // Aerosols layer (gray)
    const aerosolGeometry = new THREE.SphereGeometry(1.05, 64, 64);
    const aerosolMaterial = new THREE.MeshBasicMaterial({
        color: 0x9e9e9e,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });
    dataLayers.aerosols = new THREE.Mesh(aerosolGeometry, aerosolMaterial);
    dataEarthGroup.add(dataLayers.aerosols);
    
    // Clouds layer (white)
    const cloudDataGeometry = new THREE.SphereGeometry(1.06, 64, 64);
    const cloudDataMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });
    dataLayers.clouds = new THREE.Mesh(cloudDataGeometry, cloudDataMaterial);
    dataEarthGroup.add(dataLayers.clouds);
}

function updateDataLayers(dataset, value) {
    // Reset all layers
    Object.keys(dataLayers).forEach(key => {
        if (dataLayers[key]) {
            dataLayers[key].material.opacity = 0;
        }
    });
    
    // Activate the relevant layer based on dataset
    if (dataLayers[dataset]) {
        // Calculate opacity based on value (normalized)
        let normalizedValue = 0.5; // Default opacity
        
        switch(dataset) {
            case 'temperature':
                // Normalize temperature (-10 to 30°C) to 0-1 range
                normalizedValue = (parseFloat(value) + 10) / 40;
                break;
            case 'vegetation':
                // NDVI is already in 0-1 range
                normalizedValue = parseFloat(value);
                break;
            case 'water_vapor':
                // Normalize water vapor (0-50 g/kg) to 0-1 range
                normalizedValue = parseFloat(value) / 50;
                break;
            case 'aerosol':
                // AOD is already in 0-1 range
                normalizedValue = parseFloat(value);
                break;
            case 'clouds':
                // Normalize clouds (0-100%) to 0-1 range
                normalizedValue = parseFloat(value) / 100;
                break;
        }
        
        // Clamp the value between 0.2 and 0.8 for better visibility
        normalizedValue = Math.max(0.2, Math.min(0.8, normalizedValue));
        
        // Set the opacity with animation
        animateLayerOpacity(dataLayers[dataset], normalizedValue);
    }
    
    activeDataset = dataset;
}

function animateLayerOpacity(layer, targetOpacity) {
    const startOpacity = layer.material.opacity;
    const change = targetOpacity - startOpacity;
    const duration = 1000; // 1 second
    const startTime = Date.now();
    
    function updateOpacity() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Use ease-in-out function for smooth animation
        const easeProgress = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        layer.material.opacity = startOpacity + change * easeProgress;
        
        if (progress < 1) {
            requestAnimationFrame(updateOpacity);
        }
    }
    
    updateOpacity();
}

function onDataMouseDown(event) {
    dataIsMouseDown = true;
    dataPreviousMousePosition = {
        x: event.clientX,
        y: event.clientY
    };
}

function onDataMouseMove(event) {
    if (dataIsMouseDown) {
        const deltaMove = {
            x: event.clientX - dataPreviousMousePosition.x,
            y: event.clientY - dataPreviousMousePosition.y
        };
        
        dataTargetRotationY += deltaMove.x * 0.01;
        dataTargetRotationX += deltaMove.y * 0.01;
        
        dataPreviousMousePosition = {
            x: event.clientX,
            y: event.clientY
        };
    }
}

function onDataMouseUp() {
    dataIsMouseDown = false;
}

function onDataTouchStart(event) {
    if (event.touches.length === 1) {
        dataIsMouseDown = true;
        dataPreviousMousePosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
    }
}

function onDataTouchMove(event) {
    if (event.touches.length === 1 && dataIsMouseDown) {
        event.preventDefault();
        const deltaMove = {
            x: event.touches[0].clientX - dataPreviousMousePosition.x,
            y: event.touches[0].clientY - dataPreviousMousePosition.y
        };
        
        dataTargetRotationY += deltaMove.x * 0.01;
        dataTargetRotationX += deltaMove.y * 0.01;
        
        dataPreviousMousePosition = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
    }
}

function onDataTouchEnd() {
    dataIsMouseDown = false;
}

function onDataMouseWheel(event) {
    event.preventDefault();
    const delta = event.deltaY * 0.001;
    dataCamera.position.z = Math.max(1.5, Math.min(4, dataCamera.position.z + delta));
}

function animateDataGlobe() {
    requestAnimationFrame(animateDataGlobe);
    
    // Auto-rotate when not interacting
    if (!dataIsMouseDown) {
        dataTargetRotationY += 0.002;
    }
    
    // Smooth rotation
    dataEarthGroup.rotation.x += (dataTargetRotationX - dataEarthGroup.rotation.x) * 0.05;
    dataEarthGroup.rotation.y += (dataTargetRotationY - dataEarthGroup.rotation.y) * 0.05;
    
    // Limit vertical rotation
    dataEarthGroup.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, dataEarthGroup.rotation.x));
    
    // Rotate clouds slightly faster than Earth
    if (dataClouds) {
        dataClouds.rotation.y += 0.0005;
    }
    
    // Animate active data layer
    if (activeDataset && dataLayers[activeDataset]) {
        // Add subtle pulsing effect to the active layer
        const time = Date.now() * 0.001;
        const pulseFactor = 0.05 * Math.sin(time * 2);
        const baseScale = 1.0 + (Object.keys(dataLayers).indexOf(activeDataset) * 0.01);
        dataLayers[activeDataset].scale.set(baseScale + pulseFactor, baseScale + pulseFactor, baseScale + pulseFactor);
    }
    
    dataRenderer.render(dataScene, dataCamera);
}

// Custom Data Query functionality
document.getElementById('queryForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    // Get form values
    const date = document.getElementById('date').value;
    const dataset = document.getElementById('dataset').value;
    const area = parseFloat(document.getElementById('area').value);
    
    // Get location values
    const location = document.getElementById('location').value;
    const latitude = parseFloat(document.getElementById('latitude').value);
    const longitude = parseFloat(document.getElementById('longitude').value);
    
    // Validate inputs
    if (!date || !dataset || !location || isNaN(latitude) || isNaN(longitude)) {
        showError('Please fill in all required fields with valid values.');
        return;
    }
    
    // Validate latitude and longitude ranges
    if (latitude < -90 || latitude > 90) {
        showError('Latitude must be between -90 and 90 degrees.');
        return;
    }
    
    if (longitude < -180 || longitude > 180) {
        showError('Longitude must be between -180 and 180 degrees.');
        return;
    }
    
    // Hide any previous error messages
    hideError();
    
    // Show loading state
    const queryResult = document.getElementById('queryResult');
    queryResult.classList.remove('active');
    
    // Update map marker with selected location
    if (worldMap && latitude && longitude) {
        if (selectedLocationMarker) {
            selectedLocationMarker.setLatLng([latitude, longitude]);
        } else {
            selectedLocationMarker = L.marker([latitude, longitude], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(worldMap);
        }
        
        // Center map on selected location
        worldMap.setView([latitude, longitude], 5);
    }
    
    // Fetch data based on query
    try {
        const data = await fetchCustomData(date, latitude, longitude, dataset, area);
        displayQueryResult(data, date, location, latitude, longitude, dataset);
    } catch (error) {
        showError(`Error fetching data: ${error.message}`);
    }
});

// Fetch custom data from NASA API
async function fetchCustomData(date, lat, lon, dataset, area) {
    try {
        // Get additional data based on dataset
        let additionalData = {};
        
        try {
            switch(dataset) {
                case 'temperature':
                    additionalData = await fetchTemperatureForLocation(lat, lon, date);
                    break;
                case 'vegetation':
                    additionalData = await fetchNDVIForLocation(lat, lon, date);
                    break;
                case 'aerosol':
                    additionalData = await fetchAODForLocation(lat, lon, date);
                    break;
                case 'water_vapor':
                    additionalData = await fetchWaterVaporForLocation(lat, lon, date);
                    break;
                case 'clouds':
                    additionalData = await fetchCloudDataForLocation(lat, lon, date);
                    break;
            }
        } catch (error) {
            console.error('Error fetching additional data:', error);
            // Use mock data if additional data fetch fails
            additionalData = {
                value: generateMockValue(dataset),
                unit: getUnitForDataset(dataset),
                quality: 'Good'
            };
        }
        
        return {
            date: date,
            dataset: dataset,
            value: additionalData.value || generateMockValue(dataset),
            unit: additionalData.unit || getUnitForDataset(dataset),
            quality: additionalData.quality || 'Good'
        };
    } catch (error) {
        console.error('Error fetching custom data:', error);
        // Return mock data if API fails
        return {
            date: date,
            dataset: dataset,
            value: generateMockValue(dataset),
            unit: getUnitForDataset(dataset),
            quality: 'Good'
        };
    }
}

// Fetch temperature data for specific location
async function fetchTemperatureForLocation(lat, lon, date) {
    try {
        // Using NASA POWER API for temperature data
        const startDate = new Date(date);
        const endDate = new Date(date);
        endDate.setDate(endDate.getDate() + 1);
        
        // Format date as YYYYMMDD
        const startDateStr = `${startDate.getFullYear()}${String(startDate.getMonth() + 1).padStart(2, '0')}${String(startDate.getDate()).padStart(2, '0')}`;
        const endDateStr = `${endDate.getFullYear()}${String(endDate.getMonth() + 1).padStart(2, '0')}${String(endDate.getDate()).padStart(2, '0')}`;
        
        const url = `https://power.larc.nasa.gov/api/temporal/daily/point?start=${startDateStr}&end=${endDateStr}&latitude=${lat}&longitude=${lon}&community=SB&parameters=T2M&format=JSON`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`NASA POWER API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Check if the response has the expected structure
        if (data && data.properties && data.properties.parameter && data.properties.parameter.T2M) {
            const tempData = data.properties.parameter.T2M;
            
            // Try to get the temperature for the specific date
            let temperature = tempData[startDateStr];
            
            // If the exact date is not available, try to get any available temperature
            if (!temperature) {
                const availableDates = Object.keys(tempData);
                if (availableDates.length > 0) {
                    temperature = tempData[availableDates[0]];
                }
            }
            
            if (temperature !== undefined && temperature !== null) {
                return {
                    value: temperature.toFixed(2),
                    unit: '°C',
                    quality: 'Good'
                };
            }
        }
        
        // If we couldn't get valid temperature data, use mock data
        return {
            value: generateMockValue('temperature'),
            unit: '°C',
            quality: 'Estimated'
        };
    } catch (error) {
        console.error('Error fetching temperature data:', error);
        // Return mock data if API fails
        return {
            value: generateMockValue('temperature'),
            unit: '°C',
            quality: 'Estimated'
        };
    }
}

// Fetch NDVI data for specific location
async function fetchNDVIForLocation(lat, lon, date) {
    try {
        // Using MODIS NDVI data from NASA's Earthdata
        // This is a simplified example - in a real application, you would need to authenticate with Earthdata
        
        // For demonstration, we'll use a public dataset
        const url = `https://modis.gsfc.nasa.gov/data/dataprod/mod13.php`;
        
        // Since we can't directly query the API without authentication, we'll return mock data
        // In a real application, you would use NASA's Earthdata API with proper authentication
        
        return {
            value: generateMockValue('vegetation'),
            unit: 'NDVI',
            quality: 'Good'
        };
    } catch (error) {
        console.error('Error fetching NDVI data:', error);
        throw error;
    }
}

// Fetch Aerosol Optical Depth data for specific location
async function fetchAODForLocation(lat, lon, date) {
    try {
        // Using MODIS AOD data from NASA's Earthdata
        // This is a simplified example - in a real application, you would need to authenticate with Earthdata
        
        // For demonstration, we'll use a public dataset
        const url = `https://modis.gsfc.nasa.gov/data/dataprod/mod04.php`;
        
        // Since we can't directly query the API without authentication, we'll return mock data
        // In a real application, you would use NASA's Earthdata API with proper authentication
        
        return {
            value: generateMockValue('aerosol'),
            unit: 'AOD',
            quality: 'Good'
        };
    } catch (error) {
        console.error('Error fetching AOD data:', error);
        throw error;
    }
}

// Fetch Water Vapor data for specific location
async function fetchWaterVaporForLocation(lat, lon, date) {
    try {
        // Using MODIS Water Vapor data from NASA's Earthdata
        // This is a simplified example - in a real application, you would need to authenticate with Earthdata
        
        // For demonstration, we'll use a public dataset
        const url = `https://modis.gsfc.nasa.gov/data/dataprod/mod05.php`;
        
        // Since we can't directly query the API without authentication, we'll return mock data
        // In a real application, you would use NASA's Earthdata API with proper authentication
        
        return {
            value: generateMockValue('water_vapor'),
            unit: 'g/kg',
            quality: 'Good'
        };
    } catch (error) {
        console.error('Error fetching Water Vapor data:', error);
        throw error;
    }
}

// Fetch Cloud data for specific location
async function fetchCloudDataForLocation(lat, lon, date) {
    try {
        // Using MODIS Cloud data from NASA's Earthdata
        // This is a simplified example - in a real application, you would need to authenticate with Earthdata
        
        // For demonstration, we'll use a public dataset
        const url = `https://modis.gsfc.nasa.gov/data/dataprod/mod06.php`;
        
        // Since we can't directly query the API without authentication, we'll return mock data
        // In a real application, you would use NASA's Earthdata API with proper authentication
        
        return {
            value: generateMockValue('clouds'),
            unit: '%',
            quality: 'Good'
        };
    } catch (error) {
        console.error('Error fetching Cloud data:', error);
        throw error;
    }
}

// Generate a mock value based on dataset
function generateMockValue(dataset) {
    switch(dataset) {
        case 'temperature':
            return (Math.random() * 40 - 10).toFixed(2); // -10 to 30°C
        case 'vegetation':
            return (Math.random() * 0.8 + 0.2).toFixed(3); // 0.2 to 1.0
        case 'aerosol':
            return (Math.random() * 1.0).toFixed(3); // 0 to 1.0
        case 'water_vapor':
            return (Math.random() * 50).toFixed(2); // 0 to 50 g/kg
        case 'clouds':
            return (Math.random() * 100).toFixed(1); // 0 to 100%
        default:
            return (Math.random() * 100).toFixed(2);
    }
}

// Get unit for dataset
function getUnitForDataset(dataset) {
    switch(dataset) {
        case 'temperature':
            return '°C';
        case 'vegetation':
            return 'NDVI';
        case 'aerosol':
            return 'AOD';
        case 'water_vapor':
            return 'g/kg';
        case 'clouds':
            return '%';
        default:
            return 'units';
    }
}

// Display query results for single location
function displayQueryResult(data, date, location, lat, lon, dataset) {
    // Update result elements
    document.getElementById('resultTitle').textContent = 'Query Results';
    document.getElementById('resultDate').textContent = new Date(date).toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    });
    document.getElementById('resultLocation').textContent = location;
    document.getElementById('resultCoords').textContent = `${lat.toFixed(4)}°, ${lon.toFixed(4)}°`;
    document.getElementById('resultDataset').textContent = formatDatasetName(dataset);
    document.getElementById('resultValue').textContent = data.value;
    document.getElementById('resultUnit').textContent = data.unit;
    document.getElementById('resultQuality').textContent = data.quality;
    
    // Update the data globe with the new data
    if (dataLayers[dataset]) {
        updateDataLayers(dataset, data.value);
    }
    
    // Update the data visualization bar
    updateDataVisualizationBar(dataset, data.value);
    
    // Show the result section
    document.getElementById('queryResult').classList.add('active');
    
    // Initialize the data globe if it hasn't been initialized yet
    if (!dataScene) {
        initDataGlobe();
    }
    
    // Scroll to results
    setTimeout(() => {
        document.getElementById('queryResult').scrollIntoView({ 
            behavior: 'smooth', 
            block: 'nearest' 
        });
    }, 100);
}

// Update the data visualization bar
function updateDataVisualizationBar(dataset, value) {
    const visualizationBar = document.getElementById('dataVisualizationBar');
    const maxValue = document.getElementById('maxValue');
    const minValue = document.getElementById('minValue');
    
    // Update the gradient based on dataset type
    let gradientColors;
    switch(dataset) {
        case 'temperature':
            gradientColors = 'linear-gradient(90deg, #0377ff, #ff0000)';
            break;
        case 'vegetation':
            gradientColors = 'linear-gradient(90deg, #8bc34a, #1b5e20)';
            break;
        case 'water_vapor':
            gradientColors = 'linear-gradient(90deg, #03a9f4, #01579b)';
            break;
        case 'aerosol':
            gradientColors = 'linear-gradient(90deg, #9e9e9e, #546e7a)';
            break;
        case 'clouds':
            gradientColors = 'linear-gradient(90deg, #ffffff, #e0e0e0)';
            break;
        default:
            gradientColors = 'linear-gradient(90deg, #4fc3f7, #29b6f6)';
    }
    
    visualizationBar.style.background = gradientColors;
    
    // Update extreme values
    const normalizedValue = normalizeValueForDataset(dataset, value);
    const maxVal = 100 * normalizedValue;
    const minVal = 100 * (1 - normalizedValue);
    
    maxValue.textContent = formatValueForDataset(dataset, value);
    minValue.textContent = formatValueForDataset(dataset, value, true);
    
    // Create pixel visualization
    createPixelVisualization(normalizedValue);
}

// Normalize value for dataset
function normalizeValueForDataset(dataset, value) {
    switch(dataset) {
        case 'temperature':
            // Normalize temperature (-10 to 30°C) to 0-1 range
            return (parseFloat(value) + 10) / 40;
        case 'vegetation':
            // NDVI is already in 0-1 range
            return parseFloat(value);
        case 'water_vapor':
            // Normalize water vapor (0-50 g/kg) to 0-1 range
            return parseFloat(value) / 50;
        case 'aerosol':
            // AOD is already in 0-1 range
            return parseFloat(value);
        case 'clouds':
            // Normalize clouds (0-100%) to 0-1 range
            return parseFloat(value) / 100;
        default:
            return 0.5;
    }
}

// Format value for display
function formatValueForDataset(dataset, value, isLow = false) {
    switch(dataset) {
        case 'temperature':
            return isLow ? `${parseFloat(value).toFixed(2)}°C` : `${parseFloat(value).toFixed(2)}°C`;
        case 'vegetation':
            return isLow ? `${parseFloat(value).toFixed(3)}` : `${parseFloat(value).toFixed(3)}`;
        case 'water_vapor':
            return isLow ? `${parseFloat(value).toFixed(2)} g/kg` : `${parseFloat(value).toFixed(2)} g/kg`;
        case 'aerosol':
            return isLow ? `${parseFloat(value).toFixed(3)}` : `${parseFloat(value).toFixed(3)}`;
        case 'clouds':
            return isLow ? `${parseFloat(value).toFixed(1)}%` : `${parseFloat(value).toFixed(1)}%`;
        default:
            return value;
    }
}

// Format dataset name for display
function formatDatasetName(dataset) {
    switch(dataset) {
        case 'temperature':
            return 'Temperature';
        case 'vegetation':
            return 'Vegetation Index';
        case 'aerosol':
            return 'Aerosol Optical Depth';
        case 'water_vapor':
            return 'Water Vapor';
        case 'clouds':
            return 'Cloud Properties';
        default:
            return dataset;
    }
}

// Create pixel visualization
function createPixelVisualization(normalizedValue) {
    const pixelsContainer = document.getElementById('dataPixels');
    pixelsContainer.innerHTML = '';
    
    // Create 100 pixels in a 10x10 grid
    for (let i = 0; i < 100; i++) {
        const pixel = document.createElement('div');
        pixel.classList.add('data-pixel');
        
        // Calculate position in grid
        const row = Math.floor(i / 10);
        const col = i % 10;
        
        // Position pixel in grid
        pixel.style.position = 'absolute';
        pixel.style.left = `${col * 10}%`;
        pixel.style.top = `${row * 10}%`;
        
        // Color based on value (0-1 range)
        const hue = (1 - normalizedValue) * 240; // Red to blue
        const lightness = 0.3 + (1 - normalizedValue) * 0.7;
        pixel.style.backgroundColor = `hsl(${hue}, 70%, ${lightness * 100}%, 50%)`;
        
        pixelsContainer.appendChild(pixel);
    }
}

// Show error message
function showError(message) {
    const errorElement = document.getElementById('errorMessage');
    errorElement.textContent = message;
    errorElement.classList.add('active');
}

// Hide error message
function hideError() {
    const errorElement = document.getElementById('errorMessage');
    errorElement.classList.remove('active');
}

// Set default date to today
document.addEventListener('DOMContentLoaded', function() {
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('date').value = today;
    
    // Set max date to today
    document.getElementById('date').max = today;
    
    // Set min date to TerraForge launch date (1999-12-18)
    document.getElementById('date').min = '1999-12-18';
});